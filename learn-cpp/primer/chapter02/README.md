# 第二章相关习题解答

## 几种经典数据结构

- 基本内置类型
- 复合类型
- 自定义数据结构

其中，char、int、long、float、double、bool是最常见的基本内置类型；引用和指针是两种最重要的复合类型；struct关键字和class关键字则常用于声明用户自定义的数据结构。

变量的声明、定义和作用域，顶层const和底层const。

## 指针和引用的主要区别

指针“指向”内存中的某个对象，而引用“绑定到”内存中的某个对象，它们都实现了对其他对象的间接访问，二者的区别主要有两方面：

第一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以指向几个不同的对象；引用不是一个对象，无法令引用重新绑定到另外一个对象。  
第二，指针无须在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值；引用则必须在定义时赋初值。

## 以指针作为if的条件

指针p作为if语句的条件时，实际检验的是指针本身的值，即指针所指的地址值。如果指针指向一个真实存在的变量，则其值必不为0，此时条件为真；如果指针没有指向任何对象或者是无效指针，则对p的使用将引发不可预计的结果。

解引用运算符*p作为if语句的条件时，实际检验的是指针所指的对象内容，在上面的示例中是指针p所指的int值。如果该int值为0，则条件为假；否则，如果该int值不为0，对应条件为真。

## 判断指针是否指向了合法的对象

在C++程序中，应该尽量初始化所有指针，并且尽可能等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它有没有指向一个具体的对象了。  
其中，nullptr是C++11新标准刚刚引入的一个特殊字面值，它可以转换成任意其他的指针类型。在此前提下，判断p是否指向合法的对象，只需把p作为if语句的条件即可，如果p的值是nullptr，则条件为假；反之，条件为真。

如果不注意初始化所有指针而贸然判断指针的值，则有可能引发不可预知的结果。一种处理的办法是把if(p)置于try结构中，当程序块顺利执行时，表示p指向了合法的对象；当程序块出错跳转到catch语句时，表示p没有指向合法的对象。

## auto和decltype的区别

第一，auto类型说明符用编译器计算变量的初始值来推断其类型，而decltype虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值。  
第二，编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如，auto一般会忽略掉顶层const，而把底层const保留下来。与之相反，decltype会保留变量的顶层const。  
第三，与auto不同，decltype的结果类型与表达式形式密切相关，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用类型。
